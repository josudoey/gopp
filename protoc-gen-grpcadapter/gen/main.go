package gen

import (
	"log"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
	codesPackage   = protogen.GoImportPath("google.golang.org/grpc/codes")
	statusPackage  = protogen.GoImportPath("google.golang.org/grpc/status")
)
const deprecationComment = "// Deprecated: Do not use."

// see https://github.com/grpc/grpc-go/blob/master/cmd/protoc-gen-go-grpc/grpc.go#L85
func GenerateFile(plugin *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".grpcadapter.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	log.Printf("%v %v", filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-grpcadapter. DO NOT EDIT.")
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(plugin, file, g)
	return g
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	for _, service := range file.Services {
		genService(gen, file, g, service)
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	serverType := service.GoName + "Server"
	clientType := service.GoName + "Client"
	adapterType := service.GoName + "Adapter"
	g.P("// ", adapterType, " is the server API for ", service.GoName, " service.")
	g.P("// for forward compatibility")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
	}
	g.Annotate(adapterType, service.Location)
	g.P("type ", adapterType, " struct {")
	g.P("srv ", serverType)
	// see https://github.com/grpc/grpc-go/blob/master/cmd/protoc-gen-go-grpc/grpc.go#L162
	// see https://github.com/grpc/grpc-go/blob/master/clientconn.go
	g.P("cc ", grpcPackage.Ident("ClientConnInterface"))
	g.P("}")
	g.P()

	g.P("func New", adapterType, "(srv ", serverType, ")", clientType, "{")
	g.P("return &", adapterType, "{")
	g.P(" srv: srv,")
	g.P("}")
	g.P("}")
	g.P()

	for _, method := range service.Methods {
		g.Annotate(adapterType+"."+method.GoName, method.Location)
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			g.P("func (a *", service.GoName, "Adapter) ", clientSignature(g, method), "{")
			g.P("return a.srv.", method.GoName, "(ctx,in)")
			g.P("}")
			g.P()
			continue
		}
		g.P("func (a *", service.GoName, "Adapter) ", clientSignature(g, method), "{")
		g.P("return nil,", statusPackage.Ident("Errorf"), "(", codesPackage.Ident("Unimplemented"), `, "method `, method.GoName, ` not implemented")`)
		g.P("}")
		g.P()
	}

}

func clientSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	s := method.GoName + "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
	if !method.Desc.IsStreamingClient() {
		s += ", in *" + g.QualifiedGoIdent(method.Input.GoIdent)
	}
	s += ", opts ..." + g.QualifiedGoIdent(grpcPackage.Ident("CallOption")) + ") ("
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		s += "*" + g.QualifiedGoIdent(method.Output.GoIdent)
	} else {
		s += method.Parent.GoName + "_" + method.GoName + "Client"
	}
	s += ", error)"
	return s
}
